<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mon Appli Running üöÄ</title>
    <!-- Favicon Emoji -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üëü</text></svg>" type="image/svg+xml">
    <!-- Styles CSS int√©gr√©s -->
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
            text-align: center;
        }

        header {
            background-color: #4CAF50; /* Vert pour la course */
            color: white;
            padding: 15px 0;
            display: flex;
            justify-content.space-between;
            align-items: center;
            padding: 15px;
        }

        header h1 {
            margin: 0;
            font-size: 1.8em;
        }

        #settingsButton, #authButton {
            background: none;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            margin-left: 10px;
        }
        #authButton {
            font-size: 1em; /* Ajuster la taille pour le texte */
            padding: 5px 10px;
            border: 1px solid white;
            border-radius: 5px;
        }
        #authButton:hover {
            background-color: rgba(255,255,255,0.2);
        }

        main {
            padding: 20px;
        }

        #metrics {
            display: flex;
            flex-wrap: wrap;
            justify-content.space-around;
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-item {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            flex: 1 1 calc(50% - 40px); /* Deux colonnes sur mobile */
            min-width: 150px;
        }

        .metric-item .label {
            font-size: 0.9em;
            color: #666;
            display: block;
            margin-bottom: 5px;
        }

        .metric-item .value {
            font-size: 2.2em;
            font-weight: bold;
            color: #333;
        }

        /* Styles g√©n√©raux pour les boutons de contr√¥le */
        .control-button {
            background-color: #007bff; /* Bleu par d√©faut */
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .control-button:hover:not(:disabled) {
            background-color: #0056b3;
        }

        .control-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* Style sp√©cifique pour le bouton Arr√™ter (rouge) */
        .stop-button {
            background-color: #dc3545; /* Rouge */
            color: white; /* S'assurer que le texte est blanc */
            border: none;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .stop-button:hover:not(:disabled) {
            background-color: #c82333; /* Rouge plus fonc√© au survol */
        }

        .stop-button:disabled {
            background-color: #cccccc; /* Gris si d√©sactiv√© */
            cursor: not-allowed;
        }

        /* Styles pour les modales (g√©n√©riques) */
        .modal {
            display: none; /* Cach√©e par d√©faut - CORRIG√â */
            position: fixed; /* Reste en place m√™me en scrollant */
            z-index: 1; /* Par-dessus tout le reste */
            left: 0;
            top: 0;
            width: 100%; /* Pleine largeur */
            height: 100%; /* Pleine hauteur */
            overflow: auto; /* Permet le scroll si le contenu est trop grand */
            display: flex; /* Utiliser flex pour centrer avec justify/align-items */
            justify-content: center; /* Centrer horizontalement */
            align-items: center; /* Centrer verticalement */
            background-color: rgba(0,0,0,0.4); /* Fond semi-transparent noir */
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto; /* 15% du haut et centr√© horizontalement */
            padding: 20px;
            border: 1px solid #888;
            width: 80%; /* Largeur de la modale */
            max-width: 500px;
            border-radius: 10px;
            position: relative;
            box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .modal-content label, .modal-content input {
            display: block;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .modal-content input[type="email"],
        .modal-content input[type="password"],
        .modal-content input[type="number"] {
            width: calc(100% - 22px);
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1em;
        }

        .modal-content button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 15px;
        }

        /* Styles sp√©cifiques pour les boutons de la modale de confirmation */
        #confirmStopModal .modal-content button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            color: white; /* Assure que le texte est blanc */
            border: none;
        }
        #confirmStopModal #saveAndStopButton {
            background-color: #28a745; /* Vert pour enregistrer */
        }
        #confirmStopModal #saveAndStopButton:hover {
            background-color: #218838;
        }
        #confirmStopModal #discardAndStopButton {
            background-color: #dc3545; /* Rouge pour ne pas enregistrer */
        }
        #confirmStopModal #discardAndStopButton:hover {
            background-color: #c82333;
        }
        #confirmStopModal #cancelStopButton {
            background-color: #6c757d; /* Gris pour annuler */
        }
        #confirmStopModal #cancelStopButton:hover {
            background-color: #5a6268;
        }

        #pastRunsSection {
            margin-top: 30px;
            text-align: left;
            padding: 15px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        #pastRunsList {
            list-style: none;
            padding: 0;
        }

        #pastRunsList li {
            background-color: #f9f9f9;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #eee;
            cursor: pointer; /* Indiquer que l'√©l√©ment est cliquable */
            transition: background-color 0.2s ease;
        }
        #pastRunsList li:hover {
            background-color: #e9e9e9;
        }
        #pastRunsList li strong {
            display: block; /* La date sur une ligne s√©par√©e */
            margin-bottom: 5px;
            font-size: 1.1em;
        }

        /* Styles pour la modale d'authentification */
        #authModal .modal-content {
            text-align: center; /* Centrer le contenu de la modale d'auth */
        }
        #authModal .modal-content input {
            display: none; /* Masquer les champs email/password */
        }
        #authModal .modal-content button {
            display: block;
            width: 100%;
            margin-top: 10px;
            padding: 12px;
            font-size: 1.2em;
        }
        #authModal #googleSignInButton {
            background-color: #DB4437; /* Couleur Google Red */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        #authModal #googleSignInButton:hover {
            background-color: #c0392b;
        }
        #authModal #googleSignInButton img {
            width: 24px;
            height: 24px;
        }
        #authModal #logoutButton {
            background-color: #dc3545;
            margin-top: 20px;
        }
        #authModal #logoutButton:hover {
            background-color: #c82333;
        }
        #authModal #userStatus {
            text-align: center;
            margin-bottom: 20px;
            font-weight: bold;
            color: #555;
        }
        #authModal #toggleAuthMode {
            display: none; /* Masquer ce bouton car on n'a plus email/password */
        }


        /* Masquer la section principale si l'utilisateur n'est pas connect√© */
        #appContent {
            display: none;
        }
        #loadingScreen {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 80vh;
            font-size: 1.5em;
            color: #555;
        }


        /* Responsive pour les √©crans plus grands */
        @media (min-width: 768px) {
            .metric-item {
                flex: 1 1 calc(25% - 40px); /* Quatre colonnes sur desktop */
            }
        }
    </style>
    <!-- Pour les fonctionnalit√©s PWA, ces liens sont n√©cessaires mais les fichiers doivent exister s√©par√©ment -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#303F9F">
</head>
<body>
    <header>
        <h1>Ma Course</h1>
        <button id="authButton">Connexion</button>
        <button id="settingsButton">‚öôÔ∏è Param√®tres</button>
    </header>

    <div id="loadingScreen">
        Chargement de l'application...
    </div>

    <div id="appContent">
        <main>
            <section id="metrics">
                <div class="metric-item">
                    <span class="label">Chrono:</span>
                    <span id="chrono" class="value">00:00:00</span>
                </div>
                <div class="metric-item">
                    <span class="label">Distance:</span>
                    <span id="distance" class="value">0.00 km</span>
                </div>
                <div class="metric-item">
                    <span class="label">Vitesse Instantan√©e:</span>
                    <span id="speed" class="value">0.0 km/h</span>
                </div>
                <div class="metric-item">
                    <span class="label">Vitesse Moyenne:</span>
                    <span id="averageSpeed" class="value">0.0 km/h</span>
                </div>
                <div class="metric-item">
                    <span class="label">Statut:</span>
                    <span id="status" class="value">Pr√™t(e)</span>
                </div>
            </section>

            <section id="controls">
                <button id="startButton" class="control-button">D√©marrer</button>
                <button id="pauseButton" disabled class="control-button">Pause</button>
                <button id="stopButton" disabled class="stop-button">Arr√™ter</button>
            </section>

            <section id="mapContainer" style="height: 300px; background-color: #eee; margin-top: 20px;">
                <!-- La carte s'affichera ici -->
                <p style="text-align: center; padding-top: 130px;">Carte du parcours (apr√®s la course)</p>
            </section>

            <section id="pastRunsSection">
                <h2>Mes Courses Pr√©c√©dentes</h2>
                <ul id="pastRunsList">
                    <li style="text-align: center; color: #666;">Connectez-vous pour voir vos courses.</li>
                </ul>
            </section>
        </main>
    </div>

    <!-- Modale des param√®tres de vitesse -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeSettingsModal">&times;</span>
            <h2>Param√®tres de Vitesse</h2>
            <label for="minSpeed">Vitesse minimale optimale (km/h):</label>
            <input type="number" id="minSpeed" value="8" step="0.1"><br><br>
            <label for="maxSpeed">Vitesse maximale optimale (km/h):</label>
            <input type="number" id="maxSpeed" value="8.5" step="0.1"><br><br>
            <button id="saveSettings">Enregistrer</button>
        </div>
    </div>

    <!-- Nouvelle modale de confirmation d'arr√™t -->
    <div id="confirmStopModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeConfirmStopModal">&times;</span>
            <h2>Confirmer l'arr√™t de la course</h2>
            <p>Es-tu s√ªr(e) de vouloir arr√™ter la course ?</p>
            <button id="saveAndStopButton" class="confirm-stop-button">Oui, arr√™ter et enregistrer</button>
            <button id="discardAndStopButton" class="confirm-stop-button">Oui, arr√™ter sans enregistrer</button>
            <button id="cancelStopButton" class="confirm-stop-button">Non, continuer</button>
        </div>
    </div>

    <!-- Nouvelle Modale d'authentification (Connexion/Inscription) -->
    <div id="authModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeAuthModal">&times;</span>
            <p id="userStatus">Non connect√©</p>
            <h2 id="authTitle">Connexion</h2>
            <!-- Les champs email/password sont masqu√©s car on utilise Google Sign-In -->
            <!-- <label for="authEmail">Email:</label>
            <input type="email" id="authEmail" placeholder="ton.email@example.com"><br>
            <label for="authPassword">Mot de passe:</label>
            <input type="password" id="authPassword" placeholder="********"><br> -->
            <button id="googleSignInButton">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google icon">
                Se connecter avec Google
            </button>
            <button id="logoutButton" style="display: none;">Se d√©connecter</button>
            <!-- Le bouton toggleAuthMode est masqu√© car on n'a plus email/password -->
            <!-- <button id="toggleAuthMode">Pas de compte ? S'inscrire</button> -->
        </div>
    </div>

    <!-- Script JavaScript principal (inclut Firebase) -->
    <script type="module">
        // Importations Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, 
                 GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Ta configuration Firebase sp√©cifique
        const firebaseConfig = {
            apiKey: "AIzaSyALaUl38NTJ__0SFS3fhGpmxty4iFi2I5s",
            authDomain: "monapplirunning.firebaseapp.com",
            projectId: "monapplirunning",
            storageBucket: "monapplirunning.firebasestorage.app",
            messagingSenderId: "978266538985",
            appId: "1:978266538985:web:fa454681c9716f535f0178"
        };
        
        // L'appId est maintenant directement tir√© de ta configuration
        const appId = firebaseConfig.appId;

        // initialAuthToken est sp√©cifique √† l'environnement Canvas, garde-le pour la compatibilit√©
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app;
        let db;
        let auth;
        let userId = null; // Stocke l'ID de l'utilisateur Firebase
        let wakeLock = null; // Variable pour stocker le WakeLockSentinel

        // √âl√©ments du DOM
        const chronoDisplay = document.getElementById('chrono');
        const distanceDisplay = document.getElementById('distance');
        const speedDisplay = document.getElementById('speed');
        const averageSpeedDisplay = document.getElementById('averageSpeed');
        const statusDisplay = document.getElementById('status');
        const startButton = document.getElementById('startButton');
        const pauseButton = document.getElementById('pauseButton');
        const stopButton = document.getElementById('stopButton');
        const settingsButton = document.getElementById('settingsButton');
        const mapContainer = document.getElementById('mapContainer');
        const pastRunsList = document.getElementById('pastRunsList'); 

        // √âl√©ments de la modale des param√®tres
        const settingsModal = document.getElementById('settingsModal');
        const closeSettingsModalButton = document.getElementById('closeSettingsModal');
        const minSpeedInput = document.getElementById('minSpeed');
        const maxSpeedInput = document.getElementById('maxSpeed');
        const saveSettingsButton = document.getElementById('saveSettings');

        // √âl√©ments de la modale de confirmation d'arr√™t
        const confirmStopModal = document.getElementById('confirmStopModal');
        const closeConfirmStopModalButton = document.getElementById('closeConfirmStopModal');
        const saveAndStopButton = document.getElementById('saveAndStopButton');
        const discardAndStopButton = document.getElementById('discardAndStopButton');
        const cancelStopButton = document.getElementById('cancelStopButton');

        // Nouveaux √©l√©ments pour l'authentification
        const authButton = document.getElementById('authButton');
        const authModal = document.getElementById('authModal');
        const closeAuthModalButton = document.getElementById('closeAuthModal');
        const authTitle = document.getElementById('authTitle');
        const googleSignInButton = document.getElementById('googleSignInButton'); // Nouveau bouton
        const logoutButton = document.getElementById('logoutButton');
        const userStatusDisplay = document.getElementById('userStatus');
        const appContent = document.getElementById('appContent');
        const loadingScreen = document.getElementById('loadingScreen');

        // Variables de l'application
        let watchId; // ID pour le suivi GPS
        let startTime;
        let updatedTime;
        let difference = 0; // Temps √©coul√© en millisecondes, initialis√© √† 0
        let tInterval;
        let running = false;
        let distance = 0; // Distance totale en km
        let lastPosition = null;
        let trackPoints = []; // Pour stocker le parcours
        let minOptimalSpeed = 8; // Vitesse minimale optimale (km/h)
        let maxOptimalSpeed = 8.5; // Vitesse maximale optimale (km/h)
        let lastSpeedAnnouncement = 0; // Pour espacer les annonces de vitesse (en secondes)
        const ANNOUNCE_INTERVAL_DISTANCE = 1; // Annonce tous les 1 km
        const ANNOUNCE_INTERVAL_SPEED = 10; // Annonce de vitesse toutes les 10 secondes

        // Initialisation de Firebase et authentification
        if (firebaseConfig.apiKey) {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            onAuthStateChanged(auth, async (user) => {
                loadingScreen.style.display = 'none'; // Cacher l'√©cran de chargement
                if (user) {
                    userId = user.uid;
                    console.log("Utilisateur Firebase authentifi√© :", userId);
                    userStatusDisplay.textContent = `Connect√©(e) : ${user.displayName || user.email || 'Anonyme'}`;
                    authButton.textContent = 'D√©connexion'; // Change le texte du bouton d'authentification
                    logoutButton.style.display = 'block'; // Affiche le bouton de d√©connexion
                    googleSignInButton.style.display = 'none'; // Masque le bouton Google si d√©j√† connect√©
                    authTitle.textContent = 'Informations du compte';
                    appContent.style.display = 'block'; // Afficher le contenu de l'app
                    loadPastRuns(); // Charger les courses pr√©c√©dentes
                } else {
                    userId = null;
                    console.log("Aucun utilisateur Firebase connect√©.");
                    userStatusDisplay.textContent = 'Non connect√©(e)';
                    authButton.textContent = 'Connexion'; // Change le texte du bouton d'authentification
                    logoutButton.style.display = 'none'; // Cache le bouton de d√©connexion
                    googleSignInButton.style.display = 'block'; // Affiche le bouton Google si non connect√©
                    authTitle.textContent = 'Connexion';
                    appContent.style.display = 'none'; // Masquer le contenu de l'app si non connect√©
                    pastRunsList.innerHTML = '<li style="text-align: center; color: #666;">Connectez-vous pour voir vos courses.</li>';
                    // Tente de se connecter anonymement si aucun utilisateur n'est connect√© et qu'il y a un token initial
                    if (initialAuthToken) {
                        try {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } catch (error) {
                            console.error("Erreur d'authentification anonyme avec token initial:", error);
                        }
                    }
                }
            });
        } else {
            console.warn("Configuration Firebase non trouv√©e ou incompl√®te. Les fonctionnalit√©s de sauvegarde ne seront pas disponibles.");
            saveAndStopButton.disabled = true;
            pastRunsList.innerHTML = '<li style="text-align: center; color: #666;">Fonctionnalit√©s Firebase non disponibles (v√©rifier la configuration).</li>';
            loadingScreen.style.display = 'none';
            appContent.style.display = 'block'; // Afficher l'app m√™me sans Firebase si c'est le cas
        }

        // --- Fonctions d'authentification ---
        async function signInWithGoogle() {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
                authModal.style.display = 'none';
                speak("Connexion Google r√©ussie !");
            } catch (error) {
                console.error("Erreur de connexion Google :", error.message);
                speak("Erreur de connexion Google. Veuillez r√©essayer.");
                displayCustomAlert("Erreur de connexion Google", error.message);
            }
        }

        async function handleLogout() {
            try {
                await signOut(auth);
                authModal.style.display = 'none';
                speak("D√©connexion r√©ussie !");
            } catch (error) {
                console.error("Erreur de d√©connexion :", error.message);
                speak("Erreur de d√©connexion.");
                displayCustomAlert("Erreur de d√©connexion", error.message);
            }
        }

        // Fonction pour afficher une alerte personnalis√©e (remplace alert())
        function displayCustomAlert(title, message) {
            console.log(`ALERTE: ${title} - ${message}`);
            speak(`${title}. ${message}`);
        }


        // --- Fonctions du Chrono ---
        async function startChrono() {
            if (!running) {
                if (difference > 0 && !running) {
                    resetChrono();
                }
                
                startTime = new Date().getTime() - difference;
                tInterval = setInterval(getShowTime, 1);
                running = true;
                startButton.disabled = true;
                pauseButton.disabled = false;
                stopButton.disabled = false;
                statusDisplay.textContent = 'En cours...';
                startTrackingGPS();
                await requestWakeLock(); // Tenter d'acqu√©rir le verrouillage d'√©cran
            }
        }

        async function pauseChrono() {
            if (running) {
                clearInterval(tInterval);
                running = false;
                startButton.disabled = false;
                pauseButton.disabled = true;
                stopButton.disabled = false;
                statusDisplay.textContent = 'En pause';
                stopTrackingGPS();
                await releaseWakeLock(); // Lib√©rer le verrouillage d'√©cran
            }
        }

        // Fonction pour arr√™ter et enregistrer la course
        async function stopAndSaveRun() {
            clearInterval(tInterval);
            stopTrackingGPS();
            running = false;

            // V√©rifie si l'utilisateur est connect√© avant de tenter de sauvegarder
            if (!userId) {
                speak("Veuillez vous connecter pour enregistrer votre course.");
                displayCustomAlert("Sauvegarde impossible", "Veuillez vous connecter pour enregistrer votre course.");
                confirmStopModal.style.display = 'none';
                return;
            }

            const runData = {
                chrono: chronoDisplay.textContent,
                distance: distance,
                speed: parseFloat(speedDisplay.textContent),
                averageSpeed: parseFloat(averageSpeedDisplay.textContent),
                trackPoints: JSON.stringify(trackPoints)
            };

            await saveRunToFirestore(runData);

            startButton.disabled = false;
            pauseButton.disabled = true;
            stopButton.disabled = true;
            statusDisplay.textContent = 'Course enregistr√©e !';
            confirmStopModal.style.display = 'none';
            displayMap(); 
            await releaseWakeLock(); // Lib√©rer le verrouillage d'√©cran
        }

        // Fonction pour arr√™ter sans enregistrer la course
        async function stopWithoutSavingRun() {
            clearInterval(tInterval);
            stopTrackingGPS();
            running = false;

            resetChrono();
            
            startButton.disabled = false;
            pauseButton.disabled = true;
            stopButton.disabled = true;

            statusDisplay.textContent = 'Pr√™t(e)';
            confirmStopModal.style.display = 'none';
            await releaseWakeLock(); // Lib√©rer le verrouillage d'√©cran
        }

        function resetChrono() {
            difference = 0;
            distance = 0;
            lastPosition = null;
            trackPoints = [];
            chronoDisplay.textContent = '00:00:00';
            distanceDisplay.textContent = '0.00 km';
            speedDisplay.textContent = '0.0 km/h';
            averageSpeedDisplay.textContent = '0.0 km/h';
            mapContainer.innerHTML = '<p style="text-align: center; padding-top: 130px;">Carte du parcours (apr√®s la course)</p>';
        }

        function getShowTime() {
            updatedTime = new Date().getTime();
            difference = updatedTime - startTime;

            let hours = Math.floor((difference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            let minutes = Math.floor((difference % (1000 * 60 * 60)) / (1000 * 60));
            let seconds = Math.floor((difference % (1000 * 60)) / 1000);

            hours = (hours < 10) ? "0" + hours : hours;
            minutes = (minutes < 10) ? "0" + minutes : minutes;
            seconds = (seconds < 10) ? "0" + seconds : seconds;

            chronoDisplay.textContent = hours + ':' + minutes + ':' + seconds;

            if (difference > 0 && distance > 0) {
                const totalHours = difference / (1000 * 60 * 60);
                const avgSpeed = distance / totalHours;
                averageSpeedDisplay.textContent = avgSpeed.toFixed(1) + ' km/h';
            } else {
                averageSpeedDisplay.textContent = '0.0 km/h';
            }

            if (seconds % ANNOUNCE_INTERVAL_SPEED === 0 && seconds !== lastSpeedAnnouncement && running) {
                announceSpeedGuidance(parseFloat(speedDisplay.textContent));
                lastSpeedAnnouncement = seconds;
            }
        }

        // --- Fonctions GPS ---
        function startTrackingGPS() {
            if ("geolocation" in navigator) {
                statusDisplay.textContent = 'Localisation GPS...';
                watchId = navigator.geolocation.watchPosition(
                    (position) => {
                        const { latitude, longitude, speed } = position.coords;
                        trackPoints.push([latitude, longitude]);

                        if (lastPosition) {
                            distance += calculateDistance(lastPosition.latitude, lastPosition.longitude, latitude, longitude);
                            distanceDisplay.textContent = distance.toFixed(2) + ' km';

                            if (Math.floor(distance) > Math.floor(distance - calculateDistance(lastPosition.latitude, lastPosition.longitude, latitude, longitude)) && Math.floor(distance) % ANNOUNCE_INTERVAL_DISTANCE === 0) {
                                speak(`Vous avez parcouru ${Math.floor(distance)} kilom√®tres.`);
                            }
                        }
                        lastPosition = { latitude, longitude };

                        let currentSpeedKmh = speed ? (speed * 3.6).toFixed(1) : '0.0';
                        speedDisplay.textContent = currentSpeedKmh + ' km/h';
                    },
                    (error) => {
                        console.error("Erreur GPS :", error);
                        statusDisplay.textContent = 'Erreur GPS !';
                        speak("Probl√®me de signal GPS.");
                    },
                    {
                        enableHighAccuracy: true,
                        maximumAge: 0,
                        timeout: 5000
                    }
                );
            } else {
                statusDisplay.textContent = 'GPS non support√© par votre navigateur.';
                speak("Votre appareil ne supporte pas le GPS.");
            }
        }

        function stopTrackingGPS() {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // --- Fonctions vocales ---
        function speak(text) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'fr-FR';
                window.speechSynthesis.speak(utterance);
            } else {
                console.warn("L'API Speech Synthesis n'est pas support√©e par ce navigateur.");
            }
        }

        function announceSpeedGuidance(currentSpeed) {
            if (currentSpeed === 0) {
                statusDisplay.textContent = 'En attente...';
                return;
            }

            if (currentSpeed < minOptimalSpeed) {
                statusDisplay.textContent = `Acc√©l√©rez ! (${currentSpeed} km/h)`;
                speak("Acc√©l√©rez !");
            } else if (currentSpeed > maxOptimalSpeed) {
                statusDisplay.textContent = `Ralentissez ! (${currentSpeed} km/h)`;
                speak("Ralentissez !");
            } else {
                statusDisplay.textContent = `Bon rythme ! (${currentSpeed} km/h)`;
            }
        }

        // --- Gestion des param√®tres ---
        function loadSettings() {
            minOptimalSpeed = parseFloat(localStorage.getItem('minOptimalSpeed')) || 8;
            maxOptimalSpeed = parseFloat(localStorage.getItem('maxOptimalSpeed')) || 8.5;
            minSpeedInput.value = minOptimalSpeed;
            maxSpeedInput.value = maxOptimalSpeed;
        }

        function saveSettings() {
            minOptimalSpeed = parseFloat(minSpeedInput.value);
            maxOptimalSpeed = parseFloat(maxSpeedInput.value);
            localStorage.setItem('minOptimalSpeed', minOptimalSpeed);
            localStorage.setItem('maxOptimalSpeed', maxOptimalSpeed);
            settingsModal.style.display = 'none';
            speak("Param√®tres de vitesse enregistr√©s !");
        }

        // --- Initialisation de la carte (apr√®s la course) ---
        function displayMap() {
            if (trackPoints.length === 0) {
                mapContainer.innerHTML = '<p style="text-align: center; padding-top: 130px;">Pas de parcours enregistr√©.</p>';
                return;
            }

            if (typeof L === 'undefined') {
                const leafletCss = document.createElement('link');
                leafletCss.rel = 'stylesheet';
                leafletCss.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                document.head.appendChild(leafletCss);

                const leafletJs = document.createElement('script');
                leafletJs.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                leafletJs.onload = initializeMapWithLeaflet;
                document.head.appendChild(leafletJs);
            } else {
                initializeMapWithLeaflet();
            }
        }

        function initializeMapWithLeaflet() {
            mapContainer.innerHTML = '';
            mapContainer.id = 'mapid';

            const map = L.map('mapid').setView(trackPoints[0], 13);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            const polyline = L.polyline(trackPoints, { color: 'blue' }).addTo(map);
            map.fitBounds(polyline.getBounds());
        }


        // --- Fonctions Firebase (d√©plac√©es ici pour la port√©e) ---

        async function saveRunToFirestore(runData) {
            if (!db || !userId) {
                console.error("Firestore ou User ID non disponible. Impossible d'enregistrer la course.");
                return;
            }

            try {
                const runsCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/runs`);
                await addDoc(runsCollectionRef, {
                    ...runData,
                    timestamp: new Date()
                });
                console.log("Course enregistr√©e avec succ√®s dans Firestore !");
                speak("Course enregistr√©e !");
            } catch (e) {
                console.error("Erreur lors de l'ajout du document: ", e);
                speak("Erreur lors de l'enregistrement de la course.");
                displayCustomAlert("Erreur lors de l'enregistrement", e.message);
            }
        }

        function loadPastRuns() {
            if (!db || !userId) {
                console.warn("Firestore ou User ID non disponible. Impossible de charger les courses.");
                pastRunsList.innerHTML = '<li style="text-align: center; color: #666;">Connectez-vous pour voir vos courses.</li>';
                return;
            }

            const runsCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/runs`);
            onSnapshot(runsCollectionRef, (snapshot) => {
                pastRunsList.innerHTML = '';

                if (snapshot.empty) {
                    pastRunsList.innerHTML = '<li style="text-align: center; color: #666;">Aucune course enregistr√©e pour le moment.</li>';
                    return;
                }

                const runs = [];
                snapshot.forEach((doc) => {
                    runs.push({ id: doc.id, ...doc.data() });
                });

                runs.sort((a, b) => (b.timestamp?.seconds || 0) - (a.timestamp?.seconds || 0));

                runs.forEach((run) => {
                    const li = document.createElement('li');
                    li.classList.add('past-run-item'); // Ajout d'une classe pour le style si besoin
                    li.dataset.runId = run.id; // Stocke l'ID du document Firebase

                    const date = run.timestamp ? new Date(run.timestamp.seconds * 1000).toLocaleString('fr-FR') : 'Date inconnue';
                    const distanceKm = run.distance ? run.distance.toFixed(2) : '0.00';
                    const avgSpeedKmh = run.averageSpeed ? run.averageSpeed.toFixed(1) : '0.0';

                    li.innerHTML = `
                        <strong>${date}</strong><br>
                        Dur√©e: ${run.chrono || 'N/A'}<br>
                        Distance: ${distanceKm} km<br>
                        Vitesse moyenne: ${avgSpeedKmh} km/h
                    `;
                    pastRunsList.appendChild(li);
                });
            }, (error) => {
                console.error("Erreur lors du chargement des courses :", error);
                pastRunsList.innerHTML = '<li style="text-align: center; color: #dc3545;">Erreur de chargement des courses.</li>';
            });
        }

        // --- Fonctions Wake Lock ---
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock a √©t√© rel√¢ch√©.');
                    });
                    console.log('Wake Lock acquis !');
                } catch (err) {
                    console.error(`${err.name}, ${err.message}`);
                    displayCustomAlert("Erreur Wake Lock", "Impossible de maintenir l'√©cran allum√©.");
                }
            } else {
                console.warn("L'API Wake Lock n'est pas support√©e par ce navigateur.");
            }
        }

        async function releaseWakeLock() {
            if (wakeLock) {
                try {
                    await wakeLock.release();
                    wakeLock = null;
                    console.log('Wake Lock lib√©r√©.');
                } catch (err) {
                    console.error(`Erreur lors de la lib√©ration du Wake Lock: ${err.name}, ${err.message}`);
                }
            }
        }

        // --- √âv√©nements ---
        startButton.addEventListener('click', startChrono);
        pauseButton.addEventListener('click', pauseChrono);

        stopButton.addEventListener('click', () => {
            if (difference > 0) {
                confirmStopModal.style.display = 'flex';
            }
        });

        settingsButton.addEventListener('click', () => {
            loadSettings();
            settingsModal.style.display = 'flex';
        });

        closeSettingsModalButton.addEventListener('click', () => {
            settingsModal.style.display = 'none';
        });

        saveSettingsButton.addEventListener('click', saveSettings);

        closeConfirmStopModalButton.addEventListener('click', () => {
            confirmStopModal.style.display = 'none';
        });

        saveAndStopButton.addEventListener('click', stopAndSaveRun);
        discardAndStopButton.addEventListener('click', stopWithoutSavingRun);
        cancelStopButton.addEventListener('click', () => {
            confirmStopModal.style.display = 'none';
        });

        // √âv√©nements pour la modale d'authentification
        authButton.addEventListener('click', () => {
            authModal.style.display = 'flex'; // Utiliser flex pour centrer avec justify/align-items
            if (auth.currentUser) { // Si d√©j√† connect√©
                googleSignInButton.style.display = 'none'; // Masque le bouton Google
                logoutButton.style.display = 'block'; // Affiche le bouton de d√©connexion
                authTitle.textContent = 'Informations du compte';
            } else { // Si non connect√©
                googleSignInButton.style.display = 'block'; // Affiche le bouton Google
                logoutButton.style.display = 'none'; // Masque le bouton de d√©connexion
                authTitle.textContent = 'Connexion';
            }
        });

        closeAuthModalButton.addEventListener('click', () => {
            authModal.style.display = 'none';
        });

        googleSignInButton.addEventListener('click', signInWithGoogle); // √âv√©nement pour le bouton Google
        logoutButton.addEventListener('click', handleLogout);


        window.addEventListener('click', (event) => {
            if (event.target === settingsModal) {
                settingsModal.style.display = 'none';
            }
            if (event.target === confirmStopModal) {
                confirmStopModal.style.display = 'none';
            }
            if (event.target === authModal) { // Fermer la modale d'authentification en cliquant en dehors
                authModal.style.display = 'none';
            }
        });

        // G√©rer le r√©-acquisition du wake lock si la page redevient visible et que la course est en cours
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible' && running) {
                console.log('Page visible, tentant de r√©-acqu√©rir le Wake Lock.');
                await requestWakeLock();
            }
        });


        document.addEventListener('DOMContentLoaded', loadSettings);

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Correction du chemin du Service Worker
                navigator.serviceWorker.register('/running/service-worker.js')
                    .then(registration => {
                        console.log('ServiceWorker enregistr√© avec succ√®s :', registration);
                    })
                    .catch(error => {
                        console.log('√âchec de l\'enregistrement du ServiceWorker :', error);
                        console.warn("Le Service Worker n√©cessite un serveur web (http:// ou https://) pour fonctionner.");
                    });
            });
        }
    </script>
</body>
</html>
